# Copyright 2024 Defense Unicorns
# SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial

variables:
  - name: FLAVOR
    default: upstream
  - name: TARGET_REPO

tasks:
  - name: determine-repo
    description: Determines the OCI repository that this flavor should go into (i.e. 'unicorn' should be private)
    inputs:
      base_repo:
        description: The base repository to publish into
        default: ghcr.io/defenseunicorns/packages
      team:
        description: The team publishing the package
        default: uds
      flavor:
        description: The flavor of the package to publish
        default: ${FLAVOR}
      snapshot:
        description: Whether this is a snapshot release
        default: "false"
    actions:
      - description: Use existing TARGET_REPO value from variable
        # if the caller explicitly set a value for TARGET_REPO we'll use it
        if: ${{ ne .variables.TARGET_REPO "" }}
        cmd: echo "Using supplied value TARGET_REPO=${TARGET_REPO}"
      - description: Determine repository for the given flavor/type of release
        if: ${{ eq .variables.TARGET_REPO "" }}
        cmd: |
          repo="${{.inputs.base_repo}}"
          # unicorn flavor = private repository
          if [ "${{.inputs.flavor}}" = "unicorn" ]; then
            repo="${repo}/private"
          fi
          repo="${repo}/${{.inputs.team}}"
          # snapshots = snapshot repository
          if [ "${{.inputs.snapshot}}" = "true" ]; then
            repo="${repo}/snapshots"
          fi
          echo "${repo}"
        mute: true
        setVariables:
          - name: TARGET_REPO

  - name: pull-standard-schema-objects
    description: Output standard schema objects for uds-packages
    inputs:
      version:
        description: Version of uds-common to pull schemas from
        # x-release-please-start-version
        default: values-schema-task
        # x-release-please-end
    actions:
      - cmd: |
          repo_url=$(git config --get remote.origin.url)

          # Extract the repository name from the URL
          repo_name=$(basename -s .git "$repo_url")

          if [ "$repo_name" = "uds-common" ]; then
              ref="$(git rev-parse --abbrev-ref HEAD)"
          else
              ref="${{ .inputs.version }}"
          fi
          echo "Pull predefined schemas from uds-common"
          mkdir -p schemas
          curl -o ./schemas/custom_schema.json "https://raw.githubusercontent.com/defenseunicorns/uds-common/$ref/tasks/schemas/custom_schema.json"

  - name: generate-values-schemas
    description: Recursively generate JSON schemas for all values.yaml files in a base directory.
    inputs:
      base_dir:
        description: "Base directory to search for values.yaml files"
        default: "./chart"
        required: true
    actions:
      - task: pull-standard-schema-objects
      - description: "Find and generate schema for each values.yaml file"
        cmd: |
            # Enable debugging
            # set -x

            # Directory containing predefined schemas
            SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
            SCHEMAS_DIR="$SCRIPT_DIR/schemas"

            KEYS="custom"
            SCHEMA_FILES="$SCHEMAS_DIR/custom_schema.json"

            # Prepare jq arguments to load all schemas using --slurpfile
            # Since we have only one key, we can hardcode this part
            key="custom"
            schema_file="$SCHEMAS_DIR/custom_schema.json"

            # Debugging: Print the schema_file variable
            echo "schema_file: '$schema_file'"

            if [ ! -f "$schema_file" ]; then
              echo "Schema file not found: $schema_file"
              exit 1
            fi
            # Read the custom schema into a variable
            CUSTOM_SCHEMA=$(cat "$schema_file")


            find "${{ .inputs.base_dir }}" -name "values.yaml" | while read -r values_file; do
              schema_file_output="$(dirname "$values_file")/values.schema.json"
              echo "Generating schema for $values_file..."

              # Convert YAML to JSON
              ./uds zarf tools yq eval -o=json "$values_file" > temp.json

              # Ensure temp.json exists
              if [ ! -f temp.json ]; then
                echo "Error: temp.json not found."
                exit 1
              fi

              # Generate the base schema
              jq '
              def to_schema:
                if type == "object" then
                  {
                    "type": "object",
                    "properties": (
                      to_entries
                      | map({key: .key, value: (.value | to_schema)})
                      | from_entries
                    )
                  }
                elif type == "array" then
                  {
                    "type": "array",
                    "items": (
                      if length > 0 then
                        .[0] | to_schema
                      else
                        {}
                      end
                    )
                  }
                elif type == "string" then
                  {"type": "string"}
                elif type == "number" then
                  {"type": "number"}
                elif type == "boolean" then
                  {"type": "boolean"}
                elif type == "null" then
                  {"type": "null"}
                else
                  {}
                end;

              ( . | to_schema )
              ' temp.json > base_schema.json

              # Replace the custom field in the base schema with the predefined schema
              jq \
                --argjson customSchema "$CUSTOM_SCHEMA" \
                '.properties.custom = $customSchema' \
                base_schema.json > "$schema_file_output"

              echo "JSON schema generated at $schema_file_output"

              # Clean up temporary files
              rm temp.json base_schema.json
            done

  - name: check-values-schemas
    description: Recursively check if JSON schemas are up-to-date for all values.yaml files in a base directory.
    inputs:
      base_dir:
        description: "Base directory to search for values.yaml files"
        default: "./chart"
        required: true
    actions:
      - task: pull-standard-schema-objects
      - description: "Find and check schema for each values.yaml file"
        cmd: |
          set +e
          differences_found=0

          # Directory containing predefined schemas
          SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
          SCHEMAS_DIR="$SCRIPT_DIR/schemas"

          key="custom"
          schema_file="$SCHEMAS_DIR/custom_schema.json"

          # Check if the schema file exists
          if [ ! -f "$schema_file" ]; then
            echo "Schema file not found: $schema_file"
            exit 1
          fi

          # Read the custom schema into a variable
          CUSTOM_SCHEMA=$(cat "$schema_file")

          # Collect all values.yaml files
          values_files=$(find "${{ .inputs.base_dir }}" -name "values.yaml")

          # Iterate over the values.yaml files using a for loop
          for values_file in $values_files; do
            schema_file_output="$(dirname "$values_file")/values.schema.json"
            echo "Processing $values_file..."

            # Convert YAML to JSON
            yq eval -o=json "$values_file" > temp.json

            # Ensure temp.json exists
            if [ ! -f temp.json ]; then
              echo "Error: temp.json not found."
              exit 1
            fi

            # Generate the base schema
            jq '
            def to_schema:
              if type == "object" then
                {
                  "type": "object",
                  "properties": (
                    to_entries
                    | map({key: .key, value: (.value | to_schema)})
                    | from_entries
                  )
                }
              elif type == "array" then
                {
                  "type": "array",
                  "items": (
                    if length > 0 then
                      .[0] | to_schema
                    else
                      {}
                    end
                  )
                }
              elif type == "string" then
                {"type": "string"}
              elif type == "number" then
                {"type": "number"}
              elif type == "boolean" then
                {"type": "boolean"}
              elif type == "null" then
                {"type": "null"}
              else
                {}
              end;

            ( . | to_schema )
            ' temp.json > base_schema.json

            # Replace the custom field in the base schema with the predefined schema
            jq \
              --argjson customSchema "$CUSTOM_SCHEMA" \
              '.properties.custom = $customSchema' \
              base_schema.json > temp_generated_schema.json

            # Clean up temporary files
            rm temp.json base_schema.json

            # Paths to existing and generated schemas
            existing_schema="$schema_file_output"
            temp_generated_schema="temp_generated_schema.json"

            if [ ! -f "$existing_schema" ]; then
                echo "Existing schema not found at $existing_schema"
                differences_found=1
                continue
            fi

            # Normalize both JSON schemas (sort keys recursively)
            normalized_existing="$(mktemp)"
            normalized_generated="$(mktemp)"

            jq -S . "$existing_schema" > "$normalized_existing"
            jq -S . "$temp_generated_schema" > "$normalized_generated"

            # Compare the normalized schemas
            diff_output=$(diff "$normalized_existing" "$normalized_generated")
            diff_exit_code=$?

            if [ $diff_exit_code -eq 0 ]; then
                echo "Schemas match for chart at $(dirname "$values_file")."
            else
                echo "Schemas do not match for chart at $(dirname "$values_file")!"
                echo "Differences:"
                echo "$diff_output"
                differences_found=1
            fi

            # Clean up temporary files
            rm "$normalized_existing" "$normalized_generated" "$temp_generated_schema"

          done

          if [ $differences_found -eq 1 ]; then
              echo "Schema differences found."
              exit 1
          else
              echo "All schemas match."
              exit 0
          fi
