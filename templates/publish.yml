# Copyright 2024 Defense Unicorns
# SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial

spec:
  inputs:
    runsOn:
      default: uds
    flavor:
    artifact_dir:
      default: .ci_artifacts
    reports-path:
      default: ""
    registry1Username:
      default: ${IRON_BANK_ROBOT_USERNAME}
    registry1Password:
      default: ${IRON_BANK_ROBOT_PASSWORD}
    chainguardIdentity:
      default: ${CHAINGUARD_IDENTITY}
    targetRepo:
      default: ${CI_REGISTRY}/${CI_PROJECT_NAMESPACE}/${CI_PROJECT_NAME}
    team:
      default: uds
---

publish:
  variables:
    GIT_STRATEGY: clone
    GIT_DEPTH: 0
  id_tokens:
    CHAINGUARD_TOKEN:
      aud: https://console-api.enforce.dev
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_ID
      variables:         # Override DRY_RUN defined
        DRY_RUN: "true"  # at the job level.
  script:
    # Dry run on non-tag runs
    - OPTIONS="--no-progress"
    - if [[ "$DRY_RUN" == "true" ]]; then OPTIONS="$OPTIONS --dry-run"; fi

    # Environment setup
    - |
      uds run actions:authenticate-registries --set REGISTRY1_USERNAME="$[[ inputs.registry1Username ]]" \
                                              --set REGISTRY1_PASSWORD="$[[ inputs.registry1Password ]]" \
                                              --set CHAINGUARD_IDENTITY="$[[ inputs.chainguardIdentity ]]" \
                                              --set CHAINGUARD_TOKEN="$CHAINGUARD_TOKEN" \
                                              --set GITLAB_REGISTRY_URL="$CI_REGISTRY" \
                                              --set GITLAB_REGISTRY_USER="$CI_REGISTRY_USER" \
                                              --set GITLAB_REGISTRY_TOKEN="$CI_REGISTRY_PASSWORD"

    # Check if release is necessary for flavor and exit early if not
    - |
      if [[ "$DRY_RUN" == "true" ]]; then
        echo "Dry run, skipping check if release is required: uds-releaser check ${FLAVOR}"
      else
        if ! uds-releaser check ${FLAVOR}; then echo "No release necessary"; exit 0; fi
      fi

    # Modify zarf package and uds bundle to have the correct version
    - |
      if [[ "$DRY_RUN" == "true" ]]; then
        echo "Dry run, skipping release command: uds-releaser update-yaml ${FLAVOR}"
      else
        uds-releaser update-yaml ${FLAVOR}
      fi

    # Publish Package
    - |
        echo uds run publish-package --set FLAVOR="$[[ inputs.flavor ]]"\
                                     --set VERSION="$(uds zarf tools yq ".flavors[] | select(.name == \"${FLAVOR}\") | .version" releaser.yaml)"\
                                     --set TEAM="$[[ inputs.team ]]"\
                                     ${OPTIONS}

    # Create tag and release
    - |
      if [[ "$DRY_RUN" == "true" ]]; then
        echo "Dry run, skipping release"
      else
        uds-releaser release gitlab "${FLAVOR}"
      fi

  after_script:
    # Save logs, which will run even if the script section fails
    - echo -e "\e[0Ksection_start:`date +%s`:afterscript_section[collapsed=true]\r\e[0KAfter Script Output"
    - |
      mkdir -p $[[ inputs.artifact_dir ]]/logs
      uds run actions:debug-output --set LOG_DIR="$[[ inputs.artifact_dir ]]/logs"
      uds run actions:save-logs --set LOG_DIR="$[[ inputs.artifact_dir ]]/logs"
      # gitlab only supports one artifact unless you define a specific supported "report type"
      # so in this generic case we will just add the reports to the included artifact dir
      if [ -n "$[[ inputs.reports-path ]]" ]; then
          cp -r "$[[ inputs.reports-path ]]" "$[[ inputs.artifact_dir ]]"
      fi
    - echo -e "\e[0Ksection_end:`date +%s`:afterscript_section\r\e[0K"

  artifacts:
    when: always
    name: artifacts-$[[ inputs.flavor ]]-${CI_PIPELINE_ID}-${CI_JOB_ID}
    paths:
      # Save debug logs as artifacts
      - $[[ inputs.artifact_dir ]]
      - oscal-assessment-results.yaml

  tags:
    - $[[ inputs.runsOn ]]
