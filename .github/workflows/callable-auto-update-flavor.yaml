# Copyright 2024 Defense Unicorns
# SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial

name:
  callable-auto-update
  # Scan the sboms in the package, grab the image digests, and compare to the current upstream image digests of the same tag. If
  # the digests don't match in any image, then bump the uds version to trigger
  # a new release.

on:
  workflow_call:
    inputs:
      udsCliVersion:
        description: The uds-cli version to install
        # renovate: datasource=github-tags depName=defenseunicorns/uds-cli versioning=semver
        default: 0.28.2
        type: string
      zarfYamlPath:
        description: The path to the zarf.yaml file
        default: zarf.yaml
        type: string
      packagePrefix:
        description: The prefix for public packages
        default: ""
        type: string
      privatePackagePrefix:
        description: The prefix for private packages
        default: private
        type: string
      flavor:
        description: The flavor of the package to scan
        type: string
        required: true

# Permissions for the GITHUB_TOKEN used by the workflow.
permissions:
  contents: write # Allows us to read files from the repository for scanning, and writing the bumped releaser.yaml if applicable.
  packages: read # Allows us to pull the sboms from the published packages for comparison.

jobs:
  # figure out location of package for current flavor and arch
  # pull sboms out of package
  # scan sboms
  # pull image url out of sbom
  # compare sbom container digest to url image digest
  # if any two image digests are different, then bump the uds version in releaser.yaml
  compare-digests:
    runs-on: ubuntu-latest
    outputs:
      sboms: ${{ steps.get-sboms.outputs.sboms }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Install UDS CLI
        uses: defenseunicorns/setup-uds@ab842abcad1f7a3305c2538e3dd1950d0daacfa5 # v1.0.1
        with:
          version: v${{ inputs.udsCliVersion }}

      - name: Environment setup
        run: |
          echo "MARU_AUTH=\"{\"raw.githubusercontent.com\": \"${{ secrets.GITHUB_TOKEN }}\"}\"" >> "GITHUB_ENV"
          uds run actions:setup-environment \
          --set REGISTRY1_USERNAME="${{ secrets.IRON_BANK_ROBOT_USERNAME }}" \
          --set REGISTRY1_PASSWORD="${{ secrets.IRON_BANK_ROBOT_PASSWORD }}" \
          --set GH_TOKEN="${{ secrets.GITHUB_TOKEN }}" \
          --set RAPIDFORT_USERNAME="${{ secrets.RAPIDFORT_USERNAME }}" \
          --set RAPIDFORT_PASSWORD="${{ secrets.RAPIDFORT_PASSWORD }}"
        shell: bash

      - name: Scan SBOMs and compare digests to upstream images
        id: image-comparison
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          REPO_OWNER: ${{ github.repository_owner }}
          PACKAGE_PREFIX: ${{ inputs.packagePrefix }}
          PRIVATE_PACKAGE_PREFIX: ${{ inputs.privatePackagePrefix }}
          FLAVOR: ${{ inputs.flavor }}
        run: |
          set -Eeuo pipefail

          # Check if releaser.yaml exists
          if [[ ! -f releaser.yaml ]]; then
            echo "No releaser.yaml found, skipping..."
            exit 0
          fi

          TAG=$(yq -r '.flavors[] | select(.name == env(FLAVOR)) | (.version + "-" + .name)' releaser.yaml)
          PACKAGE_NAME=$(yq e '.metadata.name' ${{ inputs.zarfYamlPath }})

          echo "Package name: ${PACKAGE_NAME}"

          # Handle org-specific prefix
          if [[ $REPO_OWNER == "defenseunicorns" ]]; then
            PUBLIC_BASE="packages/uds"
            PRIVATE_BASE="packages/private/uds"
          else
            PUBLIC_BASE="${PACKAGE_PREFIX:-}"
            PRIVATE_BASE="${PRIVATE_PACKAGE_PREFIX:-}"
          fi

          # Construct URLs
          PUBLIC_URL="${PUBLIC_BASE:+${PUBLIC_BASE}/}${PACKAGE_NAME}"
          PRIVATE_URL="${PRIVATE_BASE:+${PRIVATE_BASE}/}${PACKAGE_NAME}"

          echo "Public package URL: ${PUBLIC_URL}"
          echo "Private package URL: ${PRIVATE_URL}"

          # Check for public or private package
          if MANIFEST_OUTPUT=$(uds zarf tools registry manifest "ghcr.io/${REPO_OWNER}/${PUBLIC_URL}:${TAG}" 2>/dev/null); then
            echo "Public package found: oci://ghcr.io/${REPO_OWNER}/${PUBLIC_URL}:${TAG}"
            PACKAGE_URL="${PUBLIC_URL}"
          else
            # Try private next
            if MANIFEST_OUTPUT=$(uds zarf tools registry manifest "ghcr.io/${REPO_OWNER}/${PRIVATE_URL}:${TAG}" 2>/dev/null); then
              echo "Private package found: oci://ghcr.io/${REPO_OWNER}/${PRIVATE_URL}:${TAG}"
              PACKAGE_URL="${PRIVATE_URL}"
            else
              echo "No package found for flavor ${FLAVOR} with tag ${TAG}"
              echo "Tried oci://ghcr.io/${REPO_OWNER}/${PUBLIC_URL}:${TAG} and oci://ghcr.io/${REPO_OWNER}/${PRIVATE_URL}:${TAG}"
              exit 1
            fi
          fi

          # Iterate over package architectures
          PACKAGE_ARCHS=$(echo "$MANIFEST_OUTPUT" | jq -r '.manifests[].platform.architecture')

          for arch in $PACKAGE_ARCHS; do
            SBOM_PATH="${PACKAGE_NAME}-${arch}"

            uds zarf package inspect sbom "oci://ghcr.io/${REPO_OWNER}/${PACKAGE_URL}:${TAG}" -a "$arch" --output "$SBOM_PATH"

            mkdir -p "${SBOM_PATH}/sboms"
            mv "${SBOM_PATH}"/"${PACKAGE_NAME}"/*.json "${SBOM_PATH}"/sboms/

            # Iterate over sboms
            # For each sbom, check if the image digest is the same as the upstream image digest
            for sbom in "${SBOM_PATH}"/sboms/*; do
              IMAGE_NAME=$(jq -r '.source.name' "$sbom")
              IMAGE_ID=$(jq -r '.source.metadata.imageID' "$sbom")
              IMAGE_VERSION=$(jq -r '.source.version' "$sbom")
              mkdir -p bump-status

              CONFIG_DIGEST=$(
              docker buildx imagetools inspect --raw \
                  "$IMAGE_NAME@$(
                  docker buildx imagetools inspect "$IMAGE_NAME:$IMAGE_VERSION" \
                      --format '{{ json .Manifest }}' \
                  | jq -r --arg arch "$arch" '
                      if has("manifests") then
                          .manifests[]
                          | select(.platform.os=="linux" and .platform.architecture==$arch)
                          | .digest
                      else
                          .digest
                      end
                      '
                  )" \
              | jq -r '.config.digest'
              )

              if [ "$IMAGE_ID" != "$CONFIG_DIGEST" ]; then
                  echo "Digest mismatch. Flagging for bump."
                  echo "mismatch=true" >> "$GITHUB_OUTPUT"
                  echo "TRUE" > "bump-status/${FLAVOR}-mismatch.txt"
                  break
              else
                  echo "Digest match for $IMAGE_NAME:$IMAGE_VERSION"
              fi
            done
          done

      - name: Save Releaser Bump Status
        if: ${{ steps.image-comparison.outputs.mismatch == 'true' }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: update-${{ inputs.flavor }}
          path: bump-status/${{ inputs.flavor}}-mismatch.txt
