# Copyright 2024 Defense Unicorns
# SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial

name:
  callable-auto-update
  # Scan the sboms in the package, grab the image digests, and compare to the current upstream image digests of the same tag. If
  # the digests don't match in any image, then bump the uds version to trigger
  # a new release.

on:
  workflow_call:
    inputs:
      udsCliVersion:
        description: The uds-cli version to install
        # renovate: datasource=github-tags depName=defenseunicorns/uds-cli versioning=semver
        default: 0.27.6
        type: string
      zarfYamlPath:
        description: The path to the zarf.yaml file
        default: zarf.yaml
        type: string
      packagePrefix:
        description: The prefix for public packages
        default: ""
        type: string
      privatePackagePrefix:
        description: The prefix for private packages
        default: private
        type: string
      flavor:
        description: The flavor of the package to scan
        type: string
        required: true

# Permissions for the GITHUB_TOKEN used by the workflow.
permissions:
  contents: write # Allows us to read files from the repository for scanning, and writing the bumped releaser.yaml if applicable.
  packages: read # Allows us to pull the sboms from the published packages for comparison.

jobs:
  # figure out location of package for current flavor and arch
  # pull sboms out of package
  # scan sboms
  # pull image url out of sbom
  # compare sbom container digest to url image digest
  # if any two image digests are different, then bump the uds version in releaser.yaml
  compare-digests:
    runs-on: ubuntu-latest
    outputs:
      sboms: ${{ steps.get-sboms.outputs.sboms }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Install UDS CLI
        uses: defenseunicorns/setup-uds@ab842abcad1f7a3305c2538e3dd1950d0daacfa5 # v1.0.1
        with:
          version: v${{ inputs.udsCliVersion }}

      - name: Environment setup
        run: |
          echo "MARU_AUTH=\"{\"raw.githubusercontent.com\": \"${{ secrets.GITHUB_TOKEN }}\"}\"" >> "GITHUB_ENV"
          uds run actions:setup-environment \
          --set REGISTRY1_USERNAME="${{ secrets.IRON_BANK_ROBOT_USERNAME }}" \
          --set REGISTRY1_PASSWORD="${{ secrets.IRON_BANK_ROBOT_PASSWORD }}" \
          --set GH_TOKEN="${{ secrets.GITHUB_TOKEN }}" \
          --set RAPIDFORT_USERNAME="${{ secrets.RAPIDFORT_USERNAME }}" \
          --set RAPIDFORT_PASSWORD="${{ secrets.RAPIDFORT_PASSWORD }}"
        shell: bash

      - name: Scan SBOMs and compare digests to upstream images
        id: image-comparison
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          REPO_OWNER: ${{ github.repository_owner }}
          PACKAGE_PREFIX: ${{ inputs.packagePrefix }}
          PRIVATE_PACKAGE_PREFIX: ${{ inputs.privatePackagePrefix }}
          FLAVOR: ${{ inputs.flavor }}
        run: |
          TAG=$(yq -r '.flavors[] | select(.name == env(FLAVOR)) | (.version + "-" + .name)' releaser.yaml)
          PACKAGE_NAME=$(yq e '.metadata.name' ${{ inputs.zarfYamlPath }})

          echo "Package name: ${PACKAGE_NAME}"
          # Set public prefix based on org and if package prefix is empty
          if [[ $REPO_OWNER == "defenseunicorns" ]]; then
            PUBLIC_URL="packages/uds/${PACKAGE_NAME}"
          elif [[ -z "$PACKAGE_PREFIX" ]]; then
            PUBLIC_URL="${PACKAGE_NAME}"
          else
            PUBLIC_URL="${PACKAGE_PREFIX}/${PACKAGE_NAME}"
          fi

          echo "Public package URL: ${PUBLIC_URL}"

          # Set private prefix based on org and if private package prefix is empty
          if [[ $REPO_OWNER == "defenseunicorns" ]]; then
            PRIVATE_URL="packages/private/uds/${PACKAGE_NAME}"
          elif [[ -z "$PRIVATE_PACKAGE_PREFIX" ]]; then
            PRIVATE_URL="${PACKAGE_NAME}"
          else
            PRIVATE_URL="${PRIVATE_PACKAGE_PREFIX}/${PACKAGE_NAME}"
          fi

          echo "Private package URL: ${PRIVATE_URL}"

          # Check for the public package
          if uds zarf package inspect sbom "oci://ghcr.io/${REPO_OWNER}/${PUBLIC_URL}:${TAG}" >/dev/null 2>&1; then
            echo "Public package found: oci://ghcr.io/${REPO_OWNER}/${PUBLIC_URL}:${TAG}"
          elif uds zarf package inspect sbom "oci://ghcr.io/${REPO_OWNER}/${PRIVATE_URL}:${TAG}" >/dev/null 2>&1; then
            echo "Private package found: oci://ghcr.io/${REPO_OWNER}/${PRIVATE_URL}:${TAG}"
          else
            echo "No package found for flavor ${FLAVOR} with tag ${TAG}"
            echo "Tried oci://ghcr.io/${REPO_OWNER}/${PUBLIC_URL}:${TAG} and oci://ghcr.io/${REPO_OWNER}/${PRIVATE_URL}:${TAG}"
            exit 1
          fi

          mkdir -p sboms
          mv "${PACKAGE_NAME}"/*.json sboms/

          SBOM_JSON="[]"

          # Iterate over sboms
          # For each sbom, check if the image digest is the same as the upstream image digest
          for sbom in sboms/*; do

            SBOM_NAME=$(basename "$sbom")
            IMAGE_NAME=$(jq -r '.source.name' $sbom)
            IMAGE_ID=$(jq -r '.source.metadata.imageID' $sbom)
            IMAGE_VERSION=$(jq -r '.source.version' $sbom)
            mismatch=false
            mkdir -p bump-status
            
            CONFIG_DIGEST=$(
            docker buildx imagetools inspect --raw \
                "$IMAGE_NAME@$(
                docker buildx imagetools inspect "$IMAGE_NAME:$IMAGE_VERSION" \
                    --format '{{ json .Manifest }}' \
                | jq -r '
                    if has("manifests") then
                        .manifests[]
                        | select(.platform.os=="linux" and .platform.architecture=="amd64")
                        | .digest
                    else
                        .digest
                    end
                    '
                )" \
            | jq -r '.config.digest'
            )

            if [ "$IMAGE_ID" != "$CONFIG_DIGEST" ]; then
                echo "Digest mismatch. Flagging for bump."
                mismatch=true
                echo "mismatch=true" >> "$GITHUB_OUTPUT"
                echo "TRUE" > "bump-status/${FLAVOR}-mismatch.txt"
                break
            else
                echo "Digest match for $IMAGE_NAME:$IMAGE_VERSION"
            fi
          done

      - name: Save Releaser Bump Status
        if: ${{ steps.image-comparison.outputs.mismatch == 'true' }}
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: update-${{ inputs.flavor }}
          path: bump-status/${{ inputs.flavor}}-mismatch.txt
