# Copyright 2024 Defense Unicorns
# SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial

name:
  callable-auto-update
  # Scan the sboms in the package, grab the image digests, and compare to the current upstream image digests of the same tag. If
  # the digests don't match in any image, then bump the uds version to trigger
  # a new release.

on:
  workflow_call:
    inputs:
      udsCliVersion:
        description: The uds-cli version to install
        # renovate: datasource=github-tags depName=defenseunicorns/uds-cli versioning=semver
        default: 0.27.19
        type: string
      zarfYamlPath:
        description: The path to the zarf.yaml file
        default: zarf.yaml
        type: string
      packagePrefix:
        description: The prefix for public packages
        default: ""
        type: string
      privatePackagePrefix:
        description: The prefix for private packages
        default: private
        type: string
      dry-run:
        description: Enable dry-run mode, which doesn't commits changes to the repository.
        default: false
        type: boolean

# Permissions for the GITHUB_TOKEN used by the workflow.
permissions:
  contents: write # Allows us to read files from the repository for scanning, and writing the bumped releaser.yaml if applicable.
  packages: read # Allows us to pull the sboms from the published packages for comparison.
  pull-requests: write # Allows us to create a PR if needed.

jobs:
  get-flavors:
    runs-on: ubuntu-latest
    outputs:
      flavors: ${{ steps.get-flavors.outputs.flavors }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Get flavors
        id: get-flavors
        run: |
          FLAVORS="$(yq -o=json -I=0 '[.components[].only.flavor | select(. != null)] | unique' '${{ inputs.zarfYamlPath }}')"
          echo "flavors=${FLAVORS}" >> "$GITHUB_OUTPUT"

  scan-flavor:
    needs: get-flavors
    strategy:
      matrix:
        flavor: ${{ fromJson(needs.get-flavors.outputs.flavors) }}
    uses: ./.github/workflows/callable-auto-update-flavor.yaml
    secrets: inherit
    with:
      udsCliVersion: ${{ inputs.udsCliVersion }}
      zarfYamlPath: ${{ inputs.zarfYamlPath }}
      packagePrefix: ${{ inputs.packagePrefix }}
      privatePackagePrefix: ${{ inputs.privatePackagePrefix }}
      flavor: ${{ matrix.flavor }}

  commit-changes:
    runs-on: ubuntu-latest
    needs: scan-flavor
    steps:
      - name: Download Releaser Bump Status Results
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        with:
          path: bump-status
          pattern: update-*

      - name: Check if any flavors need to be bumped
        id: decide-bump
        run: |
          set -Eeuo pipefail
          mkdir -p bump-status
          UPDATES=$(ls -1 bump-status/)
          if [ -z "$UPDATES" ]; then
            echo "No updates found."
            echo "bump=false" >> "$GITHUB_OUTPUT"
          else
            echo "Updates found:"
            echo "${UPDATES}"
            echo "bump=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        # if: ${{ steps.decide-bump.outputs.bump == 'true' }}
        with:
          ref: ${{ github.head_ref || github.ref_name }}
          fetch-depth: 0

      - name: Download Releaser Bump Status Results
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        if: ${{ steps.decide-bump.outputs.bump == 'true' }}
        with:
          path: bump-status
          pattern: update-*

      - name: Bump versions in releaser.yaml
        if: ${{ steps.decide-bump.outputs.bump == 'true' }}
        run: |
          # This job will bump the releaser.yaml version for the specified flavor.
          set -Eeuo pipefail
          echo "Bumping versions in releaser.yaml"
          ls bump-status
          for update in bump-status/*; do
            fname="$(basename "$update")"
            flavor="${fname#update-}"
            export flavor

            version=$(yq e -r '.flavors[] | select(.name == env(flavor)) | .version' releaser.yaml)

            main_version=${version%.*}
            uds_version=${version##*.}
            new_version="${main_version}.$((uds_version + 1))"
            export new_version

            yq e -i '
              (.flavors[]
                | select(.name == env(flavor))
                | .version
              ) = strenv(new_version)
            ' releaser.yaml
          done

          echo "New releaser.yaml"
          cat releaser.yaml

      - name: Create PR for releaser.yaml update via GraphQL
        if: ${{ steps.decide-bump.outputs.bump == 'true' && inputs.dry-run != true }}
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          BASE_BRANCH: ${{ github.head_ref || github.ref_name }}
          COMMIT_MSG: "chore(republish): update due to rebuilt images being more secure"
          PR_TITLE: "chore(republish): update releaser.yaml to republish images"
          PR_BODY: "Automated update of releaser.yaml due to rebuilt images being more secure."
          PR_LABEL: "republish"
        run: |
          # This job will create a PR to update the version in releaser.yaml, by doing the following:
          # 1. Create a new branch defined in the `PR_BRANCH` variable
          # 2. Create a commit on the new branch with new releaser.yaml version
          # 3. Create a PR from the new branch to `BASE_BRANCH` (main by default)
          # 4. Add label to the PR, defined in the `PR_LABEL` variable

          set -Eeuo pipefail
          set -x

          # Verify the file actually changed; if not, exit
          if git diff --quiet -- releaser.yaml; then
            echo "No changes to releaser.yaml; nothing to do."
            exit 0
          fi

          OWNER="${REPO%%/*}"
          NAME="${REPO#*/}"

          # Set branch name
          PR_BRANCH="republish/automated-republish"

          # Create Base64 content of releaser.yaml
          CONTENT_B64="$(base64 -w0 releaser.yaml 2>/dev/null || base64 releaser.yaml | tr -d '\n')"

          # Fetch repository ID, base branch HEAD OID, and label ID
          READ_META_GQL='
          query ($owner: String!, $name: String!, $baseRef: String!, $prRef: String!) {
            repository(owner: $owner, name: $name) {
              id
              baseRef: ref(qualifiedName: $baseRef) { target { oid } }
              prRef: ref(qualifiedName: $prRef) { id name }
            }
          }
          '

          META_JSON="$(gh api graphql \
            -f query="$READ_META_GQL" \
            -f owner="$OWNER" \
            -f name="$NAME" \
            -f baseRef="refs/heads/$BASE_BRANCH" \
            -f prRef="refs/heads/$PR_BRANCH"
          )"
          REPO_ID="$(echo "$META_JSON" | jq -r '.data.repository.id')"
          BASE_OID="$(echo "$META_JSON" | jq -r '.data.repository.baseRef.target.oid')"
          PR_REF_ID="$(echo "$META_JSON" | jq -r '.data.repository.prRef.id // empty')"

          # Look up label ID (node id) by name
          LABEL_ID=""
          LABEL_LOOKUP_GQL='
          query ($owner: String!, $name: String!, $labelName: String!) {
            repository(owner: $owner, name: $name) {
              label(name: $labelName) { id }
            }
          }
          '
          LABEL_ID="$(gh api graphql \
            -f query="$LABEL_LOOKUP_GQL" \
            -f owner="$OWNER" \
            -f name="$NAME" \
            -f labelName="$PR_LABEL" \
            --jq '.data.repository.label.id // empty'
          )"

          # Create the label if it does not exist
          if [ -z "$LABEL_ID" ]; then
            CREATE_LABEL_GQL='
            mutation ($repositoryId: ID!, $name: String!) {
              createLabel(input: {
                repositoryId: $repositoryId,
                name: $name,
                color: "d93f0b",
                description: "Auotomated job triggered for republishing images"
              }) {
                label { id }
              }
            }
            '
            LABEL_JSON="$(gh api graphql \
              -f query="$CREATE_LABEL_GQL" \
              -f repositoryId="$REPO_ID" \
              -f name="$PR_LABEL"
            )"
            LABEL_ID="$(echo "$LABEL_JSON" | jq -r '.data.createLabel.label.id')"
          fi

          if [ -n "$PR_REF_ID" ]; then
            UPDATE_REF_GQL='
            mutation ($refId: ID!, $oid: GitObjectID!) {
              updateRef(input: { refId: $refId, oid: $oid, force: true }) {
                ref { name }
              }
            }'
            gh api graphql \
              -f query="$UPDATE_REF_GQL" \
              -f refId="$PR_REF_ID" \
              -f oid="$BASE_OID" \
              --jq '.data.updateRef.ref.name'
          else
            CREATE_REF_GQL='
            mutation ($repositoryId: ID!, $refName: String!, $oid: GitObjectID!) {
              createRef(input: { repositoryId: $repositoryId, name: $refName, oid: $oid }) {
                ref { name }
              }
            }'
            gh api graphql \
              -f query="$CREATE_REF_GQL" \
              -f repositoryId="$REPO_ID" \
              -f refName="refs/heads/$PR_BRANCH" \
              -f oid="$BASE_OID" \
              --jq '.data.createRef.ref.name'
          fi

          # Create a commit on the new branch with releaser.yaml
          CREATE_COMMIT_GQL='
          mutation (
            $githubRepository: String!,
            $branchName: String!,
            $expectedHeadOid: GitObjectID!,
            $commitMessage: String!,
            $files: [FileAddition!]!
          ) {
            createCommitOnBranch(input: {
              branch: { repositoryNameWithOwner: $githubRepository, branchName: $branchName },
              message: { headline: $commitMessage },
              fileChanges: { additions: $files },
              expectedHeadOid: $expectedHeadOid
            }) {
              commit { oid url }
            }
          }
          '

          COMMIT_JSON="$(gh api graphql \
            -f query="$CREATE_COMMIT_GQL" \
            -f githubRepository="$REPO" \
            -f branchName="$PR_BRANCH" \
            -f expectedHeadOid="$BASE_OID" \
            -f commitMessage="$COMMIT_MSG" \
            -F files[][path]="releaser.yaml" \
            -F files[][contents]="$CONTENT_B64"
          )"

          echo "$COMMIT_JSON" | jq -r '.data.createCommitOnBranch.commit.url'

          # Create the pull request from PR_BRANCH -> BASE_BRANCH
          CREATE_PR_GQL='
          mutation (
            $repositoryId: ID!,
            $baseRefName: String!,
            $headRefName: String!,
            $title: String!,
            $body: String!
          ) {
            createPullRequest(input: {
              repositoryId: $repositoryId,
              baseRefName: $baseRefName,
              headRefName: $headRefName,
              title: $title,
              body: $body
            }) {
              pullRequest { id url number }
            }
          }
          '

          FIND_PR_GQL='
          query ($owner: String!, $name: String!, $head: String!, $base: String!) {
            repository(owner: $owner, name: $name) {
              pullRequests(states: OPEN, first: 20, headRefName: $head, baseRefName: $base) {
                nodes { id url number }
              }
            }
          }
          '

          PR_LOOKUP_JSON="$(gh api graphql \
            -f query="$FIND_PR_GQL" \
            -f owner="$OWNER" \
            -f name="$NAME" \
            -f head="$PR_BRANCH" \
            -f base="$BASE_BRANCH"
          )"

          PR_ID="$(echo "$PR_LOOKUP_JSON" | jq -r '.data.repository.pullRequests.nodes[0].id // empty')"
          PR_URL="$(echo "$PR_LOOKUP_JSON" | jq -r '.data.repository.pullRequests.nodes[0].url // empty')"

          if [ -n "$PR_ID" ]; then
            echo "Reusing existing PR: $PR_URL"

            UPDATE_PR_GQL='
            mutation ($pullRequestId: ID!, $title: String!, $body: String!) {
              updatePullRequest(input: { pullRequestId: $pullRequestId, title: $title, body: $body }) {
                pullRequest { id url number }
              }
            }
            '

            PR_JSON="$(gh api graphql \
              -f query="$UPDATE_PR_GQL" \
              -f pullRequestId="$PR_ID" \
              -f title="$PR_TITLE" \
              -f body="$PR_BODY"
            )"

            PR_URL="$(echo "$PR_JSON" | jq -r '.data.updatePullRequest.pullRequest.url')"
            echo "Updated PR: $PR_URL"
          else
            PR_JSON="$(gh api graphql \
              -f query="$CREATE_PR_GQL" \
              -f repositoryId="$REPO_ID" \
              -f baseRefName="$BASE_BRANCH" \
              -f headRefName="$PR_BRANCH" \
              -f title="$PR_TITLE" \
              -f body="$PR_BODY"
            )"

            PR_ID="$(echo "$PR_JSON" | jq -r '.data.createPullRequest.pullRequest.id')"
            PR_URL="$(echo "$PR_JSON" | jq -r '.data.createPullRequest.pullRequest.url')"
            echo "Created PR: $PR_URL"
          fi

          # Add the "republish" label to the PR
          ADD_LABEL_GQL='
          mutation ($labelableId: ID!, $labelIds: [ID!]!) {
            addLabelsToLabelable(input: {
              labelableId: $labelableId,
              labelIds: $labelIds
            }) {
              labelable {
                ... on PullRequest { url }
              }
            }
          }
          '

          gh api graphql \
            -f query="$ADD_LABEL_GQL" \
            -f labelableId="$PR_ID" \
            -F labelIds[]="$LABEL_ID" \
            --jq '.data.addLabelsToLabelable.labelable.url'
