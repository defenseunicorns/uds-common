# Copyright 2024 Defense Unicorns
# SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial

name: Callable-Auto-Merge-Checks

on:
  workflow_call:
    inputs:
      udsCliVersion:
        description: The uds-cli version to install
        # renovate: datasource=github-tags depName=defenseunicorns/uds-cli versioning=semver
        default: 0.27.15
        type: string
      zarfYamlPath:
        description: The path to the zarf.yaml file
        default: zarf.yaml
        type: string
      packagePrefix:
        description: The prefix for public packages
        default: ""
        type: string
      privatePackagePrefix:
        description: The prefix for private packages
        default: private
        type: string

permissions:
  contents: read
  packages: read
  pull-requests: write

concurrency:
  group: scan-${{ github.ref }}
  cancel-in-progress: true

jobs:
  check-flavors:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Install UDS CLI
        uses: defenseunicorns/setup-uds@ab842abcad1f7a3305c2538e3dd1950d0daacfa5 # v1.0.1
        with:
          version: v${{ inputs.udsCliVersion }}

      - name: Environment setup
        shell: bash
        run: |
          echo 'MARU_AUTH={"raw.githubusercontent.com":"${{ secrets.GITHUB_TOKEN }}"}' >> "$GITHUB_ENV"
          uds run actions:setup-environment \
            --set REGISTRY1_USERNAME="${{ secrets.IRON_BANK_ROBOT_USERNAME }}" \
            --set REGISTRY1_PASSWORD="${{ secrets.IRON_BANK_ROBOT_PASSWORD }}" \
            --set GH_TOKEN="${{ secrets.GITHUB_TOKEN }}" \
            --set RAPIDFORT_USERNAME="${{ secrets.RAPIDFORT_USERNAME }}" \
            --set RAPIDFORT_PASSWORD="${{ secrets.RAPIDFORT_PASSWORD }}"

      - name: Check Image Flavors
        id: check-image-flavors
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
          PACKAGE_PREFIX: ${{ inputs.packagePrefix }}
          PRIVATE_PACKAGE_PREFIX: ${{ inputs.privatePackagePrefix }}
        run: |
          set -euo pipefail

          # Single releaser expected in repo root or current working directory
          RELEASER_YAML="releaser.yaml"
          if [[ ! -f "${RELEASER_YAML}" ]]; then
            echo "No releaser.yaml found, skipping..."
            echo "No releaser.yaml found, skipping..." >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          # --- Begin: your script (paths adapted for CI workspace) ---

          # list of images to exclude example: ("cfssl-self-sign" "gitlab-sidekiq")
          EXCLUDES=()

          # Optional name rewrite rules (sed -E). Applied in order to the image NAME (left of ':').
          # Example: strip a final "-ee": 's/-ee$//'
          NAME_REWRITE_SED=()

          normalize_image() {
            # $1 is "name:tag"
            local full="$1"
            local name="${full%%:*}"
            local tag="${full#*:}"
            local n="$name"
            local expr
            for expr in "${NAME_REWRITE_SED[@]:-}"; do
              n="$(printf '%s' "$n" | sed -E "$expr")"
            done
            printf '%s:%s\n' "$n" "$tag"
          }

          is_excluded() {
            # $1 is "name:tag"
            local full="$1"
            local name="${full%%:*}"
            local pat
            for pat in "${EXCLUDES[@]:-}"; do
              [[ -n "${pat}" ]] || continue
              if [[ "$pat" == *:* ]]; then
                [[ "$full" == "$pat" ]] && return 0
              else
                [[ "$name" == "$pat" || "$name" == *"$pat"* ]] && return 0
              fi
            done
            return 1
          }

          # yq filter to extract images for a given flavor
          image_filter='
            .components[]
            | select((.only.flavor|type=="!!str") and .only.flavor == env(FLAVOR))
            | .images[]?
            | sub("^.*/"; "")                          # remove registry path
            | capture("(?<name>[^:]+):(?<tag>.*)")     # split name/tag
            | .tag |= sub("-.*$"; "")                  # strip build suffix from TAG
            | .tag |= sub("^[vV]"; "")                 # remove leading "v" or "V" from tag
            | "\(.name):\(.tag)"                       # reconstruct image name:tag
          '

          images_for_flavor() {
            local flavor="$1"
            FLAVOR="${flavor}" uds zarf tools yq -r "${image_filter}" "${ZARF_YAML}"
          }

          # Collect unique, non-null flavors
          FLAVORS="$(uds zarf tools yq -r '.components[].only.flavor | select(. != null)' "${ZARF_YAML}" | sort -u)"

          # Read flavors into array
          FLAVOR_ARR=()
          while IFS= read -r f; do
            [[ -n "${f}" ]] && FLAVOR_ARR+=("${f}")
          done <<< "${FLAVORS}"

          # Exit if no flavors found
          if [[ ${#FLAVOR_ARR[@]} -eq 0 ]]; then
            echo "No flavors found."
            echo "No flavors found in releaser.yaml." >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          # Cache images per flavor (deduped, applying exclusions and name rewrites)
          tmpdir="$(mktemp -d)"; trap 'rm -rf "'"$tmpdir"'"' EXIT
          for f in "${FLAVOR_ARR[@]}"; do
            {
              while IFS= read -r img; do
                [[ -n "$img" ]] || continue
                is_excluded "$img" && continue
                normalize_image "$img"
              done < <(images_for_flavor "${f}")
            } | sort -u > "${tmpdir}/${f}.txt" || true
          done

          # Collect mismatches to report at the end
          MISMATCHES=()

          # For each flavor, check each image against all other flavors; only record mismatches
          for src_flavor in "${FLAVOR_ARR[@]}"; do
            src_file="${tmpdir}/${src_flavor}.txt"
            [[ -s "${src_file}" ]] || continue

            while IFS= read -r image; do
              [[ -n "${image}" ]] || continue
              is_excluded "$image" && continue

              match_found=false
              for tgt_flavor in "${FLAVOR_ARR[@]}"; do
                [[ "${tgt_flavor}" == "${src_flavor}" ]] && continue
                tgt_file="${tmpdir}/${tgt_flavor}.txt"
                [[ -s "${tgt_file}" ]] || continue
                if grep -Fxq -- "${image}" "${tgt_file}"; then
                  match_found=true
                  break
                fi
              done

              if ! $match_found; then
                MISMATCHES+=("MISMATCH: '${image}' from flavor '${src_flavor}' not found in any other flavor.")
              fi
            done < "${src_file}"
          done

          if (( ${#MISMATCHES[@]} > 0 )); then
            printf '%s\n' "${MISMATCHES[@]}"
            {
              echo "## Image Flavor Consistency — Fail"
              echo ""
              echo "**Mismatches:**"
              echo '```'
              printf '%s\n' "${MISMATCHES[@]}"
              echo '```'
            } >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

          echo "All images are consistent across all flavors."
          {
            echo "## Image Flavor Consistency — OK"
            echo ""
            echo "All images are consistent across all flavors."
          } >> "$GITHUB_STEP_SUMMARY"
