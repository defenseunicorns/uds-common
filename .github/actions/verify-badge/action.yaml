name: Verify-Badge
description: Perform verification to assist with UDS badge certification

inputs:
  chartPath:
    description: Relative path to the directory with the uds-config chart
    default: chart/

runs:
  using: composite
  steps:
    - name: Setup Go environment
      uses: actions/setup-go@v5.0.2

    - name: Test installing the package
      shell: bash
      run: |

        # Validate UDS Package/Config chart is valid

        echo "::notice::ℹ️ Installing kubectl-validate..."
        go install sigs.k8s.io/kubectl-validate@latest

        echo "::notice::ℹ️ Validating uds-config chart..."
        kubectl-validate <(helm template chart ${{ inputs.chartPath }})
        echo

        # Setup

        NAMESPACE=$(yq '.components[].charts[].namespace' common/zarf.yaml | uniq)
        echo "::notice::ℹ️ Namespace: $NAMESPACE"

        UDS_PACKAGE_JSON=$(kubectl get Packages -n "${NAMESPACE}" -o jsonpath='{.items[]}')
        echo "::notice::ℹ️ Retrieved UDS Package JSON"

        UDS_PACKAGE_NAME=$(echo "$UDS_PACKAGE_JSON" | jq -r '.metadata.name')
        echo "::notice::ℹ️ Package Name: $UDS_PACKAGE_NAME"
        echo

        # Istio

        ## Must define any external interfaces under the expose key.

        ENDPOINTS="$(echo "$UDS_PACKAGE_JSON" | jq -r '.status.endpoints[]')"
        echo "::notice::ℹ️ Endpoints: $ENDPOINTS"

        for ENDPOINT in $ENDPOINTS; do
          # Curl endpoint and check that status isn't 404 or 5XX
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$ENDPOINT")
          if [ "$STATUS" -eq 404 ] || [[ $STATUS == 5* ]]; then
            echo "::error::❌ Endpoint $ENDPOINT is returning $STATUS"
          else
            echo "::notice::✅ Endpoint $ENDPOINT was successfully curl'd"
          fi
        done

        echo

        ## Must deploy and operate successfully with Istio injection enabled in the namespace.

        POD_COUNT=$(kubectl get pods -n "${NAMESPACE}" --no-headers | wc -l)

        POD_SIDECAR_COUNT=$(kubectl get pods -n "${NAMESPACE}" -o json | jq '.items[].spec.containers[] | select(.name=="istio-proxy") | length' | wc -l)

        if [ "$POD_COUNT" -ne "$POD_SIDECAR_COUNT" ]; then
          echo "::error::❌ Not all pods have the istio sidecar"
        else
          echo "::notice::✅ All pods have the istio sidecar"
        fi

        echo

        ## Should avoid workarounds such as disabling strict mTLS peer authentication.

        PEERAUTH=$(kubectl get Peerauthentication -n "${NAMESPACE}" -o=json | jq -r '.items[].spec.mtls.mode')

        if [ "$PEERAUTH" != "STRICT" ] && [ "$PEERAUTH" != "" ]; then
          echo "::error::❌ Peerauth is not strict"
        else
          echo "::notice::✅ Peerauthentication is set to strict"
        fi

        echo

        # Network Policies

        ## Must define network policies under the allow key as required.

        NETPOL_AMOUNT=$(echo "$UDS_PACKAGE_JSON" | jq -r '.spec.network.allow | length')

        if [ "$NETPOL_AMOUNT" -eq 0 ]; then
          echo "::error::❌ No network policies defined"
        else
          echo "::notice::✅ Network policies are defined"
        fi

        ## Should minimize network policies to specific selectors needed for Ingress/Egress traffic.

        NETPOL_EXT_COUNT=$(echo "$UDS_PACKAGE_JSON" | jq -r '.spec.network.allow[] | select(.remoteGenerated != "IntraNamespace") | length' | wc -l)
        echo "::notice::ℹ️ Non-IntraNamespace network policies: $NETPOL_EXT_COUNT"

        NETPOL_EXT_SELECTOR_COUNT=$(echo "$UDS_PACKAGE_JSON" | jq -r '.spec.network.allow[] | select(.remoteGenerated != "IntraNamespace") | select(.selector != null) | length' | wc -l)
        echo "::notice::ℹ️ Non-IntraNamespace network policies with selectors: $NETPOL_EXT_SELECTOR_COUNT"

        if [ "$NETPOL_EXT_COUNT" -ne "$NETPOL_EXT_SELECTOR_COUNT" ]; then
          echo "::error::❌ Not all applicable network policies are using selectors"
        else
          echo "::notice::✅ All applicable network policies are using selectors"
        fi

        NETPOL_EXT_NOTKUBE_COUNT=$(echo "$UDS_PACKAGE_JSON" | jq -r '.spec.network.allow[] | select(.remoteGenerated != "IntraNamespace") | select(.remoteGenerated != "KubeAPI") | length' | wc -l)
        echo "::notice::ℹ️ Non-IntraNamespace, non-KubeAPI network policies: $NETPOL_EXT_NOTKUBE_COUNT"

        NETPOL_EXT_NOTKUBE_PORT_COUNT=$(echo "$UDS_PACKAGE_JSON" | jq -r '.spec.network.allow[] | select(.remoteGenerated != "IntraNamespace") | select(.remoteGenerated != "KubeAPI") | select(.ports != null or .port != null) | length' | wc -l)
        echo "::notice::ℹ️ Non-IntraNamespace, non-KubeAPI network policies with ports: $NETPOL_EXT_NOTKUBE_PORT_COUNT"

        if [ "$NETPOL_EXT_NOTKUBE_COUNT" -ne "$NETPOL_EXT_NOTKUBE_PORT_COUNT" ]; then
          echo "::error::❌ Not all applicable network policies are using ports"
        else
          echo "::notice::✅ All applicable network policies are using ports"
        fi

        echo

        # Keycloak

        SSO_CLIENT_COUNT=$(echo "$UDS_PACKAGE_JSON" |  jq -r '.spec.sso | length')

        ## Must use and create a Keycloak client through the sso key if the application provides a user login.
        if [ "$SSO_CLIENT_COUNT" -gt 0 ]; then
          echo "::notice::ℹ️ There are $SSO_CLIENT_COUNT SSO clients defined"

          # Should consider security options during implementation to provide the most secure default possible (i.e. SAML w/SCIM vs OIDC).
          SSO_CLIENT_PROTOCOL=$(echo "$UDS_PACKAGE_JSON" | jq -r '.spec.sso[].protocol')
          if [ "$SSO_CLIENT_PROTOCOL" != "saml" ]; then
            echo "::error::❌ SAML is not the default protocol"
          else
            echo "::notice::✅ Default protocol is SAML"
          fi

          # Should name the client <App> Login (i.e. Mattermost Login) to provide login UX consistency.
          SSO_CLIENT_NAME=$(echo "$UDS_PACKAGE_JSON" | jq -r '.spec.sso[].name')
          if [ "$SSO_CLIENT_NAME" != "${UDS_PACKAGE_NAME^} Login" ]; then
            echo "::error::❌ SSO client name not in correct format"
          else
            echo "::notice::✅ SSO client name is correct"
          fi

          # Should clearly mark the client id with the group and app name uds-<group>-<application> (i.e. uds-swf-mattermost) to provide consistency in the Keycloak UI.
          SSO_CLIENT_ID=$(echo "$UDS_PACKAGE_JSON" | jq -r '.spec.sso[].clientId')
          if [ "$SSO_CLIENT_ID" != "uds-package-${UDS_PACKAGE_NAME}-${SSO_CLIENT_PROTOCOL}" ]; then
            echo "::error::❌ SSO client id not in the format uds-<group>-<application>-protocol"
          else
            echo "::notice::✅ SSO client id is correct"
          fi

          ## May end any generated secrets with -sso to easily locate them when querying the cluster.
          SSO_SECRET_NAME=$(echo "$UDS_PACKAGE_JSON" | jq -r '.spec.sso[].secretName')
          if [ "$SSO_SECRET_NAME" != "" ]; then
            echo "::notice::ℹ️ SSO secret name is defined"
            if [[ "$SSO_SECRET_NAME" != *-sso ]]; then
              echo "::error::❌ SSO secret name not in the format <application>-sso"
            else
              echo "::notice::✅ SSO secret name is in the correct format"
            fi
          fi
        else
          echo "::warning ::⚠️ No SSO configuration found, review needed"
        fi

        echo

        # Prometheus

        ## Must implement monitors for each application metrics endpoint using it's built-in chart monitors, the Package CR monitor key, or manual monitors in the config chart.

        PKG_MONITOR_COUNT=$(echo "$UDS_PACKAGE_JSON" | jq -r '.spec.monitor | length')

        if [ "$PKG_MONITOR_COUNT" -eq 0 ]; then
          echo "::notice::ℹ️ No monitors defined in the package, checking for ServiceMonitors"

          # Check for built-in serviceMonitors
          SERVICE_MONITOR_COUNT=$(kubectl get ServiceMonitor -n "${NAMESPACE}" -o json | jq -r '.items | length')
          if [ "$SERVICE_MONITOR_COUNT" -eq 0 ]; then
            echo "::notice::ℹ️ No ServiceMonitors defined, checking for PodMonitors"

            # Check for built-in podMonitors
            POD_MONITOR_COUNT=$(kubectl get PodMonitor -n "${NAMESPACE}" -o json | jq -r '.items | length')
            if [ "$POD_MONITOR_COUNT" -eq 0 ]; then
              echo "::error::❌ No monitors defined"
            else
              echo "::notice::✅ PodMonitor found"
            fi
          else
            echo "::notice::✅ ServiceMonitor found"
          fi
        else
          echo "::notice::✅ Monitor defined in UDS Package"
        fi

        echo

        # Exemptions

        ## Must minimize the scope and number of the exemptions to only what is absolutely required by the application

        EXEMPTION_COUNT=$(kubectl get Exemptions -n "${NAMESPACE}" -o json | jq -r '.items | length')
        if [ "$EXEMPTION_COUNT" -gt 0 ]; then
          echo "::warning ::⚠️ Exemptions are present, review needed"
        else
          echo "::notice::✅ No exemptions present"
        fi

        echo

        # Structure

        ## Should expose all configuration (uds.dev CRs, additional Secrets/ConfigMaps, etc) through a Helm chart (ideally in a chart or charts directory).

        COMMON_ZARF_MANIFEST_COUNT=$(cat common/zarf.yaml | yq '.components[] | select(.manifests != null) | length' | wc -l)
        if [ "$COMMON_ZARF_MANIFEST_COUNT" -gt 0 ]; then
          echo "::error::❌ Manifests present in common/zarf.yaml"
        else
          echo "::notice::✅ No manifests present in common/zarf.yaml"
        fi

        MAIN_ZARF_MANIFEST_COUNT=$(cat zarf.yaml | yq '.components[] | select(.manifests != null) | length' | wc -l)
        if [ "$MAIN_ZARF_MANIFEST_COUNT" -gt 0 ]; then
          echo "::error::❌ Manifests present in zarf.yaml"
        else
          echo "::notice::✅ No manifests present in zarf.yaml"
        fi

        ## Should implement or allow for multiple flavors (ideally with common definitions in a common directory)

        ZARF_COMPONENTS_FLAVOR_COUNT=$(cat zarf.yaml | yq '.components[] | select(.only.flavor != null) | length' | wc -l)
        if [ "$ZARF_COMPONENTS_FLAVOR_COUNT" -eq 0 ]; then
          echo "::error::❌ No flavors defined in zarf.yaml"
        else
          echo "::notice::✅ At least one flavor defined in zarf.yaml"
        fi

        echo

        # Testing

        ## Must implement Journey Testing to cover the basic user flows and features of the application, especially where an application interacts with an external service / interface.

        if [ -d "tests" ]; then
          if [ "$(ls -A tests)" ]; then
            echo "::notice::✅ Tests folder exists and has files"
          else
            echo "::error::❌ Tests folder exists but is empty"
          fi
        else
          echo "::error::❌ Tests folder does not exist"
        fi

        echo

        ## Should lint their configurations with appropriate tooling such as yamllint and zarf dev lint.

        pre-commit run -a
